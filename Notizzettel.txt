=====================================================================

Firmenseminar "Modern C++" Diamant Software GmbH Bielefeld

Peter Loos

peter.loos@gmx.de

https://github.com/pelocpp

=====================================================================

C++:

        std::string a = "Hello";
        std::string& ra = a;

        std::string* pa = new std::string("ABC");
        delete pa;

C++:    Wert-basiert
        Referenz-basiert
        Dynamische Daten // new / delete

C#:     Referenz-basiert

C#:     String s = new String();
        "Alles" liegt am HEAP

        KOPIE
                int m = value;
00007FF71E6D0B4F  mov         eax,dword ptr [value]  
00007FF71E6D0B55  mov         dword ptr [m],eax  

        REFERENZ
        int m = value;
00007FF71E6D0B00  mov         rax,qword ptr [value]  
00007FF71E6D0B07  mov         eax,dword ptr [rax]  
00007FF71E6D0B09  mov         dword ptr [m],eax  


Rule-of-Three:
==============

a) Wertzuweisungs-Operator

b) Kopier-Konstruktor

c) Destruktor

Wann: Wenn in der Klasse Pointer (new/delete)

m_data = new int[m_size]; // "array-new"
 
========================================================

Whyyyyyyyyyyyyyyyyyyyyy

C++:

Hybrid-Sprache

Objekt-Orientiert
Prozedural

Generische Programmierung   // Templates 

C++:  Bjarne Stroustrup   C with Classes

Alexander Alexandrowitsch Stepanow : Generische Prog.

Bibliothek: Standard Template Library  // 

==============================================

Regelset:

BIS C++ 17 / 20:

Wie ist das Regelwerk:   Reagierend.

Ab C++ 20: Concepts.

C#: Reflection

C++: Reflection für Arme

'Calculator': the associated constraints are not satisfied

Wie ist das Regelwerk:   Proaktives.

C / C++:

Regelwerk für implizite Datentypkonvertierung:

int + long = long

short + int = int

float + int = float

// ==========================================

auto:

A) Vereinbarung von Variablen

B) Rückgabetyp

C) auto als PARAMETER

--------------------------------------------

=======> STL

Brace 

Lambda

Neue Form der Initialisierung

B:  Brace  // geschweiften Klammern

        double d1 = ival;      // Compiles
00007FF6144F91B0  cvtsi2sd    xmm0,dword ptr [ival]  
00007FF6144F91B5  movsd       mmword ptr [d1],xmm0  


0XCCCCCCCCCCCCCC

0XDDDDDDDDDDDDDD

0XDCDCDCDCDCDCDC


        int intArray7[10]{ };
00007FF7ED30A3A9  lea         rax,[intArray7]  
00007FF7ED30A3B0  mov         rdi,rax  
00007FF7ED30A3B3  xor         eax,eax  
00007FF7ED30A3B5  mov         ecx,28h  
00007FF7ED30A3BA  rep stos    byte ptr [rdi]  

Frage:

Setzen wir Brace Init. ein ???

A) {}

B) bei "altem" Code: Nein.

C) Bei neuem Code: sehr wohl 

==========================================

Lambdas:

a) Historisch.

b) Beobachtung:

   Es gibt sehr wohl viele neue C++ Konzepte.

   =======> Viele werden auf VORHANDENES abgebildet !!!


std::vector:  Wird auch noch separat (STL) eingeführt.

std::sort ( p1, p2, p3  )

A)  glob. , freie Funktionen können an andere
    Funktionen übergeben werden.

B) Aufrufbares Objekt // Funktor // Callable Object:

 Eine Klasse, die den operator() implementiert
                               // überlädt.

=====================================

Eine freie Funktion: KEIN Objekt.

Callable object: Objekt.

Lambda: OBJEKT.

===> Lambda ist eine "Funktion". umgangssprachlich

===> Exakt: Lambda ist ein Ojekt.

Funktion:     std::bind // std::funtion

term does not evaluate to a
function taking 2 arguments


Severity	Code	Description	Project	File	Line	Suppression State	Details
Error	C2064	term does not evaluate
to a function taking 2 arguments

Seminar_DS_2026_Modern_Cp

C:\Program Files\Microsoft Visual Studio\2022\Comm


include\xutility.h	1597		

'test_xxxxx': local function definitions are illegal


Cpp  Insights:

===========================================================

Lambdas:

Auf die Schnelle: Ein Lambda ist eine
                  anonyme Funktion

Exakter:

Ein Lambda ist ein Objekt einer (anonymen) Klasse,
die den Operator operator() realisiert.

Konsequenz:

Ein Lambda-Objekt kann Daten aufnehmen
aus der Umgebung: Als Kopie oder als Referenz.




==============================================

OO:

Objekt: Methoden + Member

Lambda: Objekt

==============================================

STL

===> 

Gewissen Charme

Building Blocks:    Indices gibt es nicht mehr 

   Funktionalität:  Lambdas

=======================================================

Getting Started STL

== STL Container   // Hält Daten
== STL Iterator

== STL Algorithmen

std::vector
std::list      // linked list // Verkettete Liste
std::queue

Idee:

Design Ziel:  Man möchte Container
              austauschen können.


== STL Container   // Hält Daten


   Der Zugriff auf Elemente wird abstrahiert.

   Begriff einer Position in einem Container
   
   Was kann man mit einer Position machen:

   == Element an der Position auslesen:  operator*
   == Gehe zur nächsten Position:        operator++
   == Zwei Position vergleichen          operator==

   Wie kommen wir zu einer Position: KONTRAKT

   JEDER STL Container MUSS zwei Methoden: begin(), end()

   operator[]: Geht im Regelfall nicht.

== STL Iterator

== Zugriff auf Elemente


Alt:   typedef

Neu:   using 

C# vs. C++:   UB  - Undefined Behaviour

======================================================

STL

Container
Iteratoren
Algorithmen

    std::for_each(
        numbers.begin(),
        numbers.end(),
        [](int elem) {
            std::cout << elem << " ";
        }
    );

STD Ranges:    ===> 

    std::ranges::for_each(
        numbers,
        [](int elem) {
            std::cout << elem << " ";
        }
    );

std::vector

==> Lineare Suche

std:set

Löschen  // Suchen

for_each:

In allen anderen Sprachen:

for_each (   int elem   :  container ) {

}

for (   int elem   :  container ) {

}



C++ 11:  Range - based for Loop



warning C4834:
discarding return value of function
with [[nodiscard]] attribute

// ================================

auto zum DRITTEN:

auto als PARAMETER.


// ================================

STL

Algorithmen
Lambdas
auto

Spezialthema:  Entfernen von Elementen

Eager  Tue es jetzt   // erase

Lazy   Tue es wenn es sein muss  // remove

// ================================

Referenzen

int n;

int& ra = n;

int && 

Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
------------------------------------

RValue

Move - Semantik
---------------

i)  0x000001ff81735 340   // am Stack // wird zerstört

ii) 0x000001ff81735 6c0   // im Vektor // Kopie

-------------

i) 0x000001cba0c75 810

=====================================================================

RValue - Referenzen

Verschiebe Semantik

Smart - Pointer

=====================================================================

        constexpr Complex c3{ c1 + c2 };
00007FF7DA1C1890  movss       xmm0,dword ptr [__real@40800000 (07FF7DA40D8D4h)]  
00007FF7DA1C1898  movss       dword ptr [c3],xmm0  
00007FF7DA1C18A0  movss       xmm0,dword ptr [__real@40a00000 (07FF7DA40D8D8h)]  
00007FF7DA1C18A8  movss       dword ptr [rbp+8Ch],xmm0  

4.0  und 5.0

        Complex c3{ c1 + c2 };
00007FF7D22515DF  lea         r8,[c2]  
00007FF7D22515E3  lea         rdx,[c3]  
00007FF7D22515EA  lea         rcx,[c1]  
00007FF7D22515EE  call        ConstExprClassesAndObjects::Complex::operator+ (07FF7D21B7575h)  
00007FF7D22515F3  nop 



        // IIFE - Immediately Invoked Functional Expression:
        // some more real-world examples: regarding argument data types


        const char*   //  std::string_view

========================================================

Smart Pointer

Was ist das Problem mit new ???

Wer darf wann das delete aufrufen ??????????

// Lösung // Alternative

Idee:
-----

OO ==> Objekte

Konstruktoren // Destruktoren

C++ ==> Destruktor: Am Ende des Scopes
        
        Deterministisch

Idee: Man verstecke Zeiger (new)

      in Hüllenklassen:

      Destruktor ==> delete

auto_ptr: deprecated

std::unique_ptr

std::shared_ptr
std::weak_ptr

Strategie: std::unique_ptr

Es kann zu einem Zeitpunkt im Programm
nur EINEN Besitzer eines std::unique_ptr-Objekts geben.

Kopieren: Geht nicht.

Strategie: std::shared_ptr

Es kann zu einem Zeitpunkt im Programm
MEHRERE Besitzer eines std::shared_ptr-Objekts geben.

Kopieren: Geht.

Erste Destruktor: NICHT: Delete

Zähler aller Besitzer // Reference Counter  ==> 0

C#:  Referenz

============================================================

Go for Unique   // Besitzer

Go for Shared   // Besitzer

Beobachtung: std::shared_ptr:

   Dieser Funktioniert nicht IMMER ???

std::weak_ptr

C#:   Events

m_source += new Client();

m_source -= new Client();


=========================================

Zyklen: Bei uns doch nicht :)

Observer - Pattern

A) Ein Objekt (Source) hat Zustand,

   der von Interesse ist.

b) Es gibt Beobachter (Clients),
   die sich für den Zustand interessieren

   Beobachter =====> Source

C) Beobachter melden sich an der Source
   an  // register // attach
       unregister // Dettach

D) Source:  Eine Liste von Beobachtern verwalten 
  
   Source ======> Beobachter

i) Source:      Shared_Ptr

ii) Beobachter: Shared_Ptr

iii) In der Source:  

     Liste von Beobachtern

     // Neeeeeeeeeeeeeee
     std::vector<std::shared<Observer>>

     // Go this way ....
     std::vector<std::weak<IObserver>>

std::unique

std::shared_ptr
std::weak_ptr

========================================

std::unique

std::shared_ptr

Man kann die Lösung mit beiden Klassen 
umsetzen.

===================================================================

Utility Klassen
---------------

std::optional

C#:  int,  int?  - Nullable

int - Variable:

0 ... gültig

-1 ... gültig

-MAX_INT ...

int-Variable: value
bool          isValid;

std::pair <>

std::optional

warning C4834: discarding return value of function
with [[nodiscard]] attribute


====================================================

Zeichenketten:

std::string

SA_String

auto cp = "1111111111111111111111111";


"111111111111111111111111111111111111111111111111";

SA_String
SA_String_View

std::string

const char * 

std::string_view

A) const char *   Anfangsadresse
B) Length

string_view ist ein NON OWNING Container !!!!


===================================================

std::initializer_list

Sie ist ein Light-Weight Container:

size()
begin()
end()


std::vector<int> vec (10);  // Size: 10 - Alle: 0

std::vector<int> vec {10};  // Size: 1  - Wert: 10


std::string s { 10, 20 };    // Length: 2 

std::string s (10, 20 );     // Length: 10 - 


=============================================

Arrays

int numbers [100];


Tupel:

Structured Binding

std::tuple

ist ähnlich zu einer Struktur - für Schreibfaule.


std::tuple

REST Daten ... Interface Hell // 10 Layer: UI

DTO Data Transfer Object

========================================================

std::variant
-------------

Ein std::variant kann Daten unterschiedlichen Typs haben,
zu einem Zeitpunkt aber nur ein BESTIMMTES Datum.

Excel:  Sheet - Zelle // Cell:

Zeichenkette, num. Wert, Datum, Währung (Currency), ..

man kann einen Variant "besuchen"  :)

std::visit


if

if compile_time

C++

OO

GP















